"use strict";

exports.__esModule = true;
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _core = _interopRequireDefault(require("@svgr/core"));

var _rollupPluginutils = require("rollup-pluginutils");

var _core2 = require("@babel/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function svgrPlugin(options = {}) {
  const filter = (0, _rollupPluginutils.createFilter)(options.include || '**/*.svg', options.exclude);
  const {
    babel = true
  } = options;
  return {
    name: 'svgr',

    async transform(data, id) {
      if (!filter(id)) return null;
      if (id.slice(-4) !== '.svg') return null;

      const load = _fs.default.readFileSync(id, 'utf8');

      const exportMatches = data.match(/^module.exports\s*=\s*(.*)/) || data.match(/export\sdefault\s(.*)/);
      const previousExport = exportMatches ? data : null;
      const ast = {
        type: 'Program',
        sourceType: 'module',
        start: 0,
        end: null,
        body: []
      };
      const jsCode = await (0, _core.default)(load, options, {
        rollup: {
          previousExport
        }
      });

      const pBabelTransform = async code => new Promise((resolve, reject) => {
        (0, _core2.transform)(code, {
          babelrc: false,
          presets: ['@babel/preset-react', ['@babel/preset-env', {
            modules: false
          }]],
          plugins: ['@babel/plugin-transform-react-constant-elements']
        }, (err, result) => {
          if (err) reject(err);else resolve(result.code);
        });
      });

      if (babel) {
        const code = await pBabelTransform(jsCode);
        return {
          code,
          map: {
            mappings: ''
          }
        };
      }

      return {
        ast,
        code: jsCode,
        map: {
          mappings: ''
        }
      };
    }

  };
}

var _default = svgrPlugin;
exports.default = _default;